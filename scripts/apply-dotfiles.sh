#!/usr/bin/env bash
# Apply dotfiles via bash templates + symlinks.
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
: "${XDG_CONFIG_HOME:=${HOME}/.config}"
LOCAL_ENV_FILE="${XDG_CONFIG_HOME}/dotfiles/local.env"
DRY_RUN=false

RESET="\033[0m"
INFO_COLOR="\033[94m"
GREEN="\033[32m"
CYAN="\033[36m"
YELLOW="\033[33m"
RED="\033[31m"

log_info() {
  printf "${INFO_COLOR}> %s${RESET}\n" "$*"
}

log_debug() {
  printf "${CYAN}> %s${RESET}\n" "$*"
}

log_warn() {
  printf "${YELLOW}! %s${RESET}\n" "$*"
}

log_error() {
  printf "${RED}✖ %s${RESET}\n" "$*"
}

log_success() {
  printf "${GREEN}✔ %s${RESET}\n" "$*"
}

usage() {
  cat <<EOF
Usage: $0 [--dry-run]

Applies dotfiles by generating templates and creating symlinks.
EOF
}

run() {
  if "${DRY_RUN}"; then
    log_debug "(dry-run) $*"
    return 0
  fi
  log_debug "$*"
  "$@"
}

load_local_env() {
  if [[ -r "${LOCAL_ENV_FILE}" ]]; then
    log_debug "Loading local overrides from ${LOCAL_ENV_FILE}"
    source "${LOCAL_ENV_FILE}"
  elif [[ -n "${CI:-}" ]]; then
    MACHINE_ROLE="personal"
    log_info "CI environment detected; defaulting MACHINE_ROLE=${MACHINE_ROLE}."
  elif [[ -z "${MACHINE_ROLE:-}" ]]; then
    log_error "MACHINE_ROLE not set. Create ${LOCAL_ENV_FILE} with MACHINE_ROLE=personal|work or export it before running apply-dotfiles."
    exit 4
  fi

  if [[ -n "${MACHINE_ROLE:-}" ]] && [[ "${MACHINE_ROLE}" != "personal" && "${MACHINE_ROLE}" != "work" ]]; then
    log_error "Invalid MACHINE_ROLE=${MACHINE_ROLE}. Expected 'personal' or 'work'."
    exit 5
  fi
}

require_env_var() {
  local name="$1"
  if [[ -z "${!name:-}" ]]; then
    log_error "${name} not set. Define it in ${LOCAL_ENV_FILE} or export it before running apply-dotfiles."
    exit 6
  fi
}

ensure_parent_dir() {
  local target="$1"
  local parent
  parent="$(dirname "${target}")"
  if [[ -d "${parent}" ]]; then
    return
  fi
  if "${DRY_RUN}"; then
    log_info "Would create directory ${parent}"
    return
  fi
  run mkdir -p "${parent}"
}

backup_existing() {
  local target="$1"
  if [[ ! -e "${target}" && ! -L "${target}" ]]; then
    return 0
  fi
  local backup="${target}.backup.$(date +%Y%m%d%H%M%S)"
  if "${DRY_RUN}"; then
    log_warn "Would move existing ${target} to ${backup}"
    return 0
  fi
  run mv "${target}" "${backup}"
}

link_path() {
  local source="$1"
  local target="$2"
  ensure_parent_dir "${target}"

  if [[ -L "${target}" ]]; then
    local existing
    existing="$(readlink "${target}")"
    if [[ "${existing}" == "${source}" ]]; then
      log_info "Symlink already set: ${target} -> ${source}"
      return 0
    fi
  fi

  backup_existing "${target}"
  if "${DRY_RUN}"; then
    log_info "Would link ${target} -> ${source}"
    return 0
  fi
  run ln -s "${source}" "${target}"
}

write_gitconfig() {
  local target="${HOME}/.gitconfig"
  local git_name git_email git_signing_key git_ssh_key github_host_alias
  local gpg_program credential_helper

  require_env_var GIT_NAME
  require_env_var GIT_EMAIL
  require_env_var GIT_SIGNING_KEY

  git_name="${GIT_NAME}"
  git_email="${GIT_EMAIL}"
  git_signing_key="${GIT_SIGNING_KEY}"
  git_ssh_key="${GIT_SSH_KEY:-}"
  github_host_alias="${GIT_GITHUB_HOST_ALIAS:-}"

  case "$(uname -s)" in
    Darwin)
      gpg_program="/Applications/1Password.app/Contents/MacOS/op-ssh-sign"
      credential_helper="osxkeychain"
      ;;
    *)
      gpg_program="/opt/1Password/op-ssh-sign"
      credential_helper=""
      ;;
  esac

  if "${DRY_RUN}"; then
    log_info "Would write ${target}"
    return 0
  fi

  ensure_parent_dir "${target}"

  {
    printf "# Managed by the dotfiles repo. Generated by apply-dotfiles.sh\n\n"
    cat <<EOF
[user]
  name = ${git_name}
  email = ${git_email}
  signingKey = ${git_signing_key}

[color]
  ui = true
  diff = auto
  status = auto
  branch = auto

[core]
  editor = nvim
  excludesFile = ${XDG_CONFIG_HOME}/git/ignore
EOF
    if [[ -n "${git_ssh_key}" ]]; then
      cat <<EOF
  sshCommand = ssh -i ${git_ssh_key} -F /dev/null
EOF
    fi
    cat <<'EOF'

[apply]
  whitespace = nowarn

[diff]
  tool = nvim

[difftool]
  prompt = false

[difftool "nvim"]
  cmd = nvim --diff $LOCAL $REMOTE
  prompt = false

[help]
  autocorrect = 1

[merge]
  tool = nvim

[mergetool]
  prompt = false
  keepBackup = false

[mergetool "nvim"]
  cmd = nvim -d $LOCAL $REMOTE $MERGED -c '$wincmd w' -c 'wincmd J'

[pull]
  ff = only

[branch]
  autosetuprebase = always

[push]
  default = simple
  autoSetupRemote = true

[hub]
  protocol = https
EOF
    if [[ -n "${github_host_alias}" ]]; then
      cat <<EOF

[url "git@${github_host_alias}:"]
  insteadOf = git@github.com:
  insteadOf = git@github.com/
EOF
    fi
    cat <<EOF

[gpg]
  format = ssh

[gpg "ssh"]
  program = ${gpg_program}

[commit]
  gpgsign = true
EOF
    if [[ -n "${credential_helper}" ]]; then
      cat <<EOF

[credential]
  helper = ${credential_helper}
EOF
    fi
    cat <<'EOF'

[alias]
  co = checkout
  count = !git shortlog -sn
  head = !git r -1
  h = !git head
  l = !git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
  gpr = !git pull --rebase

[init]
  defaultBranch = main
EOF
  } >"${target}"
}

apply_symlinks() {
  local dir
  shopt -s nullglob
  for dir in "${ROOT_DIR}/config/"*; do
    [[ -d "${dir}" ]] || continue
    link_path "${dir}" "${XDG_CONFIG_HOME}/$(basename "${dir}")"
  done
  shopt -u nullglob

  link_path "${ROOT_DIR}/zshrc" "${HOME}/.zshrc"
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run)
      DRY_RUN=true
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      log_error "Unknown option: $1"
      usage
      exit 1
      ;;
  esac
  shift
done

load_local_env
write_gitconfig
apply_symlinks

log_success "Dotfiles applied."
